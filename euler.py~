# generate list of all odd numbers starting at 3 up to and including bound
def odds_list(bound):
  """
  Returns list of odds from 3 to bound (inclusive if bound is odd).
  """
  odds = [(x*2 + 1) for x in range(1,bound//2)]
  if bound % 2 == 1:
    odds.append(bound)
  return odds

#print(generate_odds(11))


def prime_list(bound):
  """
  Returns a list of all primes <= bound.
  """
  if bound < 2:
    raise ValueError('bound must be 2 or more')
  bound_root = int(bound**(1/2.0))
  odds = odds_list(bound)
  
  # x*2+3: 0->3, 1->5, 2->7, 3->9, ...
  # (x-3)/2: 3->0, 5->1, 7->2, ...
  for i in range(0,len(odds)):
    if odds[i] > bound_root: # only go up to root of bound (which could be prime)
      break                    # any composite above that has a prime divisor less than it's root
    if odds[i] != 0:
      prime = odds[i]
      ctr = 3*prime # 2*prime would be even, so skip it since we only have odd numbers in our odds list
      while ctr <= bound:
        j = (ctr-3)/2 # get odds index from number
        odds[j] = 0 # set multiples of the prime to zero
        ctr += 2*prime # our list only has odd ones, and adding one prime would make it even
    
  result = [x for x in odds if x != 0]  
  result.insert(0,2)
  return result

#print('result: ' + str(prime_list(1)))


def factorize(n, prime_list = []):
  """
  Returns prime factorization of n. 
  Faster if given a prime_list of appropriate size, otherwise generates one.
  """
  
  def test_and_remove(my_num, ctr, primes):
    # handle 1 case
    if my_num == 1:
      return
    # handle 2 case
    if my_num%2 == 0:
      if primes == []:
        primes.append(list([ctr]))
      else:
        primes[-1].append(ctr)
      if my_num / 2 == 1: # last run for a power of two
        return
      else:
        test_and_remove(my_num / 2, 2, primes)
        return
    if ctr == 2:
      ctr += 1
    
    # handle non-2 case
    my_root = my_num ** (1/2.0)
    #print('test_and_remove(' + str(my_num) + ', ' + str(ctr) + ', ' + str(primes) + ')')
    
    while ctr <= int(my_root):
      #print('my_num: ' + str(my_num) + ', ctr: ' + str(ctr) + ', primes: ' + str(primes))
      if my_num % ctr == 0:
        if primes == []:
          primes.append(list([ctr]))
        elif ctr in primes[-1]:
          primes[-1].append(ctr)
        else:
          primes.append(list([ctr]))
        test_and_remove(my_num / ctr, ctr, primes)
        return
      
      ctr += 2
    
    # final call
    #print('final call')
    if primes == []:
      primes.append(list([my_num]))
    elif my_num in primes[-1]:
      primes[-1].append(my_num)
    else:
      primes.append(list([my_num]))
    return
  
  factorization = []
  test_and_remove(n, 2, factorization)
  return factorization




